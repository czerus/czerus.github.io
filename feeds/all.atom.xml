<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Testing, Linux, Git &amp; stuff</title><link href="https://czerus.github.io/" rel="alternate"></link><link href="https://czerus.github.io/feeds/all.atom.xml" rel="self"></link><id>https://czerus.github.io/</id><updated>2017-10-16T22:20:00+02:00</updated><entry><title>(Prawie) wszystkie grzechy Bamboo</title><link href="https://czerus.github.io/prawie-wszystkie-grzechy-bamboo.html" rel="alternate"></link><published>2017-10-16T22:20:00+02:00</published><updated>2017-10-16T22:20:00+02:00</updated><author><name>czerus</name></author><id>tag:czerus.github.io,2017-10-16:/prawie-wszystkie-grzechy-bamboo.html</id><summary type="html">
&lt;p&gt;Bamboo od Atlassiana to obok Jenkinsa niemal synonim serwera Continuous Integration (CI). Od niemal dwóch lat mam okazję
używać tego narzędzia oraz dokonywać jego podstawowej konfiguracji. Niestety natknąłem się na kilka dosyć sporych
problemów, których nie spodziewałem się w narzędziu sprzedawanym za całkiem duże pieniądze.
</summary><content type="html">
&lt;p&gt;Bamboo od Atlassiana to obok Jenkinsa niemal synonim serwera Continuous Integration (CI). Od niemal dwóch lat mam okazję
używać tego narzędzia oraz dokonywać jego podstawowej konfiguracji. Niestety natknąłem się na kilka dosyć sporych
problemów, których nie spodziewałem się w narzędziu sprzedawanym za całkiem duże pieniądze.
 &lt;/p&gt;
&lt;h2&gt;1. Błędy we wbudowanych wtyczkach&lt;/h2&gt;
&lt;p&gt;Za przykład niech tu posłuży "Artifact Downloader" task. Jest to task służący do pobierania artefaktów udostępnionych 
przez inne plany. Przykładowy scenariusz użycia:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build plan tworzy binarki System Under Test (SUT) i udostępnia je innym planom jako "shared artifact".&lt;/li&gt;
&lt;li&gt;Test plan pobiera tak udostępnione artefakty, instaluje i przeprowadza testy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Okazuje się, że pobranie około 5 GB artefaktów zajmuje pluginowi około 6 minut (~112 Mbps!!! przy 1GB łączu). Sporo... 
Zwłaszcza, że wykonanie tego samego zadania w tasku typu wykonanie skryptu zajmuje nieco ponad minutę (za pomocą polecenia &lt;code&gt;curl&lt;/code&gt;). 
Oczywiście okazuje się, że &lt;a href="https://jira.atlassian.com/browse/BAM-8111"&gt;błąd&lt;/a&gt; został już zgłoszony i naprawiony. 
Mimo to w naszej (załatanej) wersji Bamboo problem dalej występuje.&lt;/p&gt;
&lt;h2&gt;2. Błędy w liczeniu czasu buildu&lt;/h2&gt;
&lt;p&gt;Czas trwania buildu liczony jest od momentu kliknięcia ikonki "Run" albo dodania buildu do kolejki przez inny build (przy dependent builds). Do realnego czasu trwania np. testów doliczany jest więc czas, który build "spędził" w poczekalni. Niby nic, ale 
bardzo to zakłamuje statystyki. Nagle wychodzi, że czas trwania uruchomienia 10 testów, które do niedawna zajmowały 10 minut
zajmuje 40. Prawdopodobnie, ktoś z zespołu zmarnuje nieco czasu próbując rozwikłać tą zagadkę. &lt;/p&gt;
&lt;p&gt;Ponadto średni czas trwania buildu jest brany pod uwagę przez wtyczkę "HungBuildKiller", która na podstawie czasu trwania
buildu ocenia czy build rzeczywiście utknął czy też nie. &lt;/p&gt;
&lt;h2&gt;3. Niekompletna dokumentacja REST API&lt;/h2&gt;
&lt;p&gt;Bamboo udostępnia &lt;a href="https://developer.atlassian.com/bamboodev/rest-apis"&gt;API&lt;/a&gt; do pobierania informacji oraz uruchamiania akcji na serwerze. Response może zostać zwrócony jako dokument XML lub JSON. Niestety dosyć obszerna dokumentacja pomija ważne fakty, np. dokumentacja label dla "Build Service" wygląda następująco:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;?label=labelname — List the latest builds which have a build result labelled with a particular label(s). labelname can be the name of a single label (e.g. deploy_failed) or a comma-separated list of label names (e.g. {deploy_failed,deploy_successful)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Możnaby się spodziewać, że &lt;code&gt;?label=moja_labelka&lt;/code&gt; zwróci wszystkie buildy mające label "moja_labelka" ale nic bardziej mylnego. Okazuje się, że są zwracane jedynie buildy z &lt;strong&gt;master&lt;/strong&gt;planów. Wszystkie branche są pomijane... I tak mając do dyspozycji API można skończyć na web scrappingu...&lt;/p&gt;
&lt;h2&gt;4. Dziwne zachowanie "Rerun failed/incomplete jobs"&lt;/h2&gt;
&lt;p&gt;"Rerun failed/incomplete jobs" jest to funkcjonalność Bamboo umożliwiająca na ponowne uruchomienie tylko tego stage'a, który 
sfailował (lub całego buildu jeżeli jest tylko jeden stage). Według dokumentacji build powinien zostać powtórzony z użyciem
tej samej rewizji kodu. Dokumentacja nie wspomina za to o tym, że nie gwarantuje użycia tych samych artefaktów jeżeli build pobiera takowe
przez nieszczęsny artifact downloader task. &lt;/p&gt;
&lt;h2&gt;5. GUI&lt;/h2&gt;
&lt;p&gt;Dotychacz używałem głównie Bamboo w wersji 5.8.x. Jakież było moje zdziwienie gdy w wersji 6.x zobaczyłem dokładnie taką samą szatę graficzną i głupie błędy w funkcjonalności. Niby nie jest źle ale nawet Jenkins poszedł do przodu a Bamboo stoi w miejscu.&lt;/p&gt;
&lt;h2&gt;6. Podejście Atlassiana do zgłaszanych błędów&lt;/h2&gt;
&lt;p&gt;Więkoszość z opisanych problemów zostało zgłoszonych w &lt;a href="https://jira.atlassian.com/projects/BAM/issues/BAM-18294?filter=allopenissues"&gt;Jirze Bamboo&lt;/a&gt;.
Są to także w większości prawdziwe bugi, a nie propozycje usprawnień. Zazwyczaj utrudniają one pracę w projekcie.
I gdy próbuje się wygooglać rozwiązania problemu znajduje się Jirę. Jirę otwartą 2, 3 a nawet 4 lata temu. Jirę nieprzypisaną do nikogo.
Jirę, do której co jakiś czas ktoś dodaje komentarz i upvotowaną w celu zwrócenia uwagi producenta, że oczekuje się naprawy. Aż ręce opadają...
I całkowicie zrozumiałbym takie zachowanie producenta każdego darmowego produktu ale nie płatnego rozwiązania.&lt;/p&gt;
&lt;h2&gt;Podsumowanie&lt;/h2&gt;
&lt;p&gt;Czy zatem Bamboo jest złe? Chyba nie. A przynajmniej nie aż tak. Zazwyczaj działa i spełnia swoje zadania dobrze. Powyższa lista to moje prywatne bolączki, które bardzo dziwią w produkcie za 4400 USD dla 10 zdalnych agentów (a to wcale nie jest dużo).&lt;/p&gt;
&lt;p&gt;Code on!&lt;/p&gt;</content><category term="bamboo"></category><category term="ci"></category></entry><entry><title>Jekyll vs Pelican</title><link href="https://czerus.github.io/jekyll-vs-pelican.html" rel="alternate"></link><published>2017-09-14T22:20:00+02:00</published><updated>2017-09-14T22:20:00+02:00</updated><author><name>czerus</name></author><id>tag:czerus.github.io,2017-09-14:/jekyll-vs-pelican.html</id><summary type="html">
&lt;p&gt;Od kilku lat coraz większą popularność zdobywają generatory statycznych stron wwww takie jak Jekyll. Dlaczego ludzie 
wybierają technologię rodem z poprzedniego wieku w dobie WordPressa? I czym właściwie jest wspomniany Jekyll i czym różni
się od Pelicana?
</summary><content type="html">
&lt;p&gt;Od kilku lat coraz większą popularność zdobywają generatory statycznych stron wwww takie jak Jekyll. Dlaczego ludzie 
wybierają technologię rodem z poprzedniego wieku w dobie WordPressa? I czym właściwie jest wspomniany Jekyll i czym różni
się od Pelicana?
 &lt;/p&gt;
&lt;h2&gt;Generator statycznych stron www&lt;/h2&gt;
&lt;p&gt;[Generator statycznych stron www przetwarza dokumenty markdown lub restructured text na strony html. Korzysta przy tym
z szablonów oraz wtyczek oferowanych przez dane środowisko. Cały content trzymany jest w plikach md lub rst, a nie w bazie
danych. Generator przetwarza zatem statyczne dokumenty na strony html według predefiniowanych szablonów uwzględnaiając
funkcjonalności dodawane przez wtyczki. Wystarczy teraz wgrać zestaw wygenerowanych dokumentów na serwer mający jedynie
Apache lub ngix. Tak wygenerowany strona/blog powinien być w założeniu bardzo szybki i bezpieczny. 
W dodatku &lt;a href="https://pages.github.com/"&gt;GitHub&lt;/a&gt; oferuje możliwość hostowania takich stron. Wystarczy założyć konto, 
włączyć osobistą stronę i wrzucić wygenerowane pliki. Będą one dostępne pod adresem: http://nazwa_zuytkownika.github.io. &lt;/p&gt;
&lt;h2&gt;Jekyll&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; jest pierwszym programem tego typu. Został stworzony przez jednego z założycieli GitHuba 
a napisany w Ruby. 
Do uruchomienia wymaga całego środowiska Ruby. Pluginy oraz szablony instalowane są za pomocą gemów. Z uwagi na swój
wiek Jekyll posiada całkiem sporą ilość rozszerzeń oraz tematów graficznych. Pierwsza wersja tego bloga została wygenerowana
właśnie z użyciem lepszej wersji Pana Hyde'a. Niestety nie wspominam tego dobrze. Środowisko Ruby zainstalowało się na 
Fedorze bez problemu, ale potem gemy itp. itd.... Trochę to trwało. Ogarnąłem szablony na tyle, aby je modyfikować, ale
dalej uważałem, że czegoś tu brakuje. I wtedy...&lt;/p&gt;
&lt;h2&gt;Pelican&lt;/h2&gt;
&lt;p&gt;...trafiłem na artykuł w &lt;a href="https://fedoramagazine.org/make-github-pages-blog-with-pelican/"&gt;Fedora Magazine&lt;/a&gt;. Okazało
się, że Pelican to pajtonowy Jekyll. Instaluje się go za pomocą zwykłego &lt;code&gt;pip install pelican&lt;/code&gt;. Plik ustawień to zwykły
plik pythona ze zmiennymi (listy, słowniki, stringi). Instalowanie rozszerzeń i tematów jest dużo prostsze. Na serio!
Jak ogarnięcie się w Jekyllu zajęło mi tydzień (głównie wieczory) tak ogarnięcie Pelicana to jeden wieczór.
Po więcej szczegółów zapraszam na &lt;a href="http://docs.getpelican.com/en/latest/"&gt;RtD&lt;/a&gt; Pelicana. 
Jednym słowem bardzo polecam szczególnie tym, którzy Pythona lubią i szanują :).&lt;/p&gt;
&lt;p&gt;Code on!&lt;/p&gt;</content><category term="jekyll"></category><category term="pelican"></category><category term="python"></category></entry><entry><title>Kontrolowanie aplikacji uruchomionej w dockerze z innego kontenera dockera</title><link href="https://czerus.github.io/kontrolowanie-aplikacji-uruchomionej-w-dockerze-z-innego-kontenera-dockera.html" rel="alternate"></link><published>2017-03-28T22:00:00+02:00</published><updated>2017-03-28T22:00:00+02:00</updated><author><name>czerus</name></author><id>tag:czerus.github.io,2017-03-28:/kontrolowanie-aplikacji-uruchomionej-w-dockerze-z-innego-kontenera-dockera.html</id><summary type="html">
&lt;p&gt;O &lt;a href="https://www.docker.com/"&gt;Dockerze&lt;/a&gt; pierwszy raz usłyszałem na 
&lt;a href="https://www.cloudbees.com/event/juc/2014/berlin"&gt;JUC 2014:Berlin&lt;/a&gt;. 
Pamiętam, że byłem zachwycony ideą konteneryzacji aplikacji jak i szybkością z jaką działają kontenery 
(w porównaniu do standardowych maszyn wirtualnych). Cały technologiczny świat zachłysnął się
kontenerami a mi przyszło rozwiązać następującą zagadkę: jak kontrolować aplikację uruchomioną
w kontenerze z poziomu innej aplikacji uruchomionej w innym kontenerze?
</summary><content type="html">
&lt;p&gt;O &lt;a href="https://www.docker.com/"&gt;Dockerze&lt;/a&gt; pierwszy raz usłyszałem na 
&lt;a href="https://www.cloudbees.com/event/juc/2014/berlin"&gt;JUC 2014:Berlin&lt;/a&gt;. 
Pamiętam, że byłem zachwycony ideą konteneryzacji aplikacji jak i szybkością z jaką działają kontenery 
(w porównaniu do standardowych maszyn wirtualnych). Cały technologiczny świat zachłysnął się
kontenerami a mi przyszło rozwiązać następującą zagadkę: jak kontrolować aplikację uruchomioną
w kontenerze z poziomu innej aplikacji uruchomionej w innym kontenerze?
&lt;/p&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;W ostatnim projekcie, w którym brałem udział natknąłem się na dosyć specyficzny
problem. Całe środowisko testowe było uruchamiane w kontenerze dockera. W tym 
samym kontenerze jest uruchomiony zarówno agent Bamboo jak i sam Robot Framework (RFW). Tak, 
wiem, niezbyt to dockerowe. Sam SUT (System Under Test) uruchomiony był w osobnym kontenerze.&lt;/p&gt;
&lt;p&gt;Testując zawsze powinniśmy być pewni w jakim stanie znajduje się SUT. Idealnie każdy test 
powinien przygotować sobie środowisko w setupie i posprzątać po sobie w teardownie.
Bardzo często do przeprowadzenia testu potrzebne jest wprowadzenie do aplikacji pewnych
danych testowych lub też wprowadzenie aplikacji w pewny znany nam stan. Pewne typy testów wymagają
zmian w OS, w którym jest uruchomiony SUT. 
W opisywanym przypadku testowana aplikacja po starcie wykonywała pewne operacje, których nie można było
wywołać z poziomu API. Aby ptrzetestować wszystkie główne scenariusze związane ze wspomnianymi
operacjami musiałem przy każdym test casie restartować SUT. Pewne scenariusze przewidywały brak 
dostępu do sieci, inne powinny wyciąć tylko komunikację na jednym porcie (i to raz wychodzącą a innym
razem przychodzącą)... Jednym słowem ciężki orzech do zgryzienia.&lt;/p&gt;
&lt;p&gt;Aby ułatwić sobie pracę podzieliłem problem na 2 mniejsze:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Restartowanie SUT.&lt;/li&gt;
&lt;li&gt;Kontrola środowiska SUT.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Po krótkim googlaniu i kilku rozmowach z programistą okazało się, że sam docker dostarcza narzędzi
do rozwiązania wspomnianych problemów.&lt;/p&gt;
&lt;h2&gt;Restartowanie SUT&lt;/h2&gt;
&lt;p&gt;Z natury kontenery dockera "śledzą" jedną uruchomioną w nich aplikację. Po wyłączeniu/
ubiciu aplikacji wyłącza się sam kontener. Tylko, że taki kontener pozostanie "martwy"
na zawsze. Chyba, że dodamy do polecenia &lt;code&gt;docker run&lt;/code&gt; opcję &lt;code&gt;--restart always&lt;/code&gt;. Wtedy
docker zrestartuje kontener:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run --restart always ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Powyższe polecenie uruchomi kontener z obrazu Ubuntu 16.04 i w przypadku, gdy główna
aplikacja zostanie wyłączona i kontener się wyłączy, zostanie automatycznie znowu włączony.&lt;/p&gt;
&lt;h2&gt;Kontrola środowiska SUT&lt;/h2&gt;
&lt;p&gt;O ile SUT nie korzysta z &lt;code&gt;volume&lt;/code&gt; do zapisywania ustawień restart spowoduje zrestartowanie
ustawień aplikacji - kontenery są lepsze niż kobiety pod tym względem - "nie pamiętają".&lt;/p&gt;
&lt;p&gt;Ale jak zrestartować samą aplikację lub kontrolować jej środowisko uruchomienia?
Z pomocą przychodzi biblioteka RFW &lt;a href="https://github.com/robotframework/RemoteInterface"&gt;Remote&lt;/a&gt;
oraz zdalny serwer &lt;code&gt;XML-RPC&lt;/code&gt;. Remote jest dosyć specyficzną biblioteką gdyż sama w sobie nie zawiera
żadnych słów kluczowych. To co potrafi to udostępnianie wszytkich keywordów biblioteki uruchomionej
z pomocą XML-RPC serwera. Neleży zatem stworzyć niemal standardową bibliotekę RFW
(poszerzoną o uruchomienie serwera XML-RPC) i umieścić ją w kontenerze SUT. W test casie
RFW dodajemy import biblioteki "Remote" z informacją gdzie znajduje się nasza zdalna biblioteka i już 
możemy używać jej keywordów, które np. za pomocą komendy &lt;code&gt;kill&lt;/code&gt; zabiją SUT a tym samym zrestartują cały kontener.
Problem solved!&lt;/p&gt;
&lt;h2&gt;Przykład&lt;/h2&gt;
&lt;p&gt;Gotowy projekt zawierający szczegółowy opis oraz przykładowe Dockerfile i bibliotekę zdalną można pobrać z mojego
repozytorium na &lt;a href="https://github.com/czerus/control_docker_from_docker"&gt;githubie&lt;/a&gt;.&lt;/p&gt;</content><category term="docker"></category><category term="robot framework"></category><category term="remote library"></category></entry><entry><title>Fedy - Łatwa konfiguracja Fedory</title><link href="https://czerus.github.io/fedy-latwa-konfiguracja-fedory.html" rel="alternate"></link><published>2017-03-11T00:39:00+01:00</published><updated>2017-03-11T00:39:00+01:00</updated><author><name>czerus</name></author><id>tag:czerus.github.io,2017-03-11:/fedy-latwa-konfiguracja-fedory.html</id><summary type="html">
&lt;p&gt;Szukając informacji jak zainstalować &lt;code&gt;Sublime Text&lt;/code&gt; na Fedorze naktnąłem się 
na narzędzie o nazwie &lt;a href="https://www.folkswithhats.org/"&gt;Fedy&lt;/a&gt;.
</summary><content type="html">
&lt;p&gt;Szukając informacji jak zainstalować &lt;code&gt;Sublime Text&lt;/code&gt; na Fedorze naktnąłem się 
na narzędzie o nazwie &lt;a href="https://www.folkswithhats.org/"&gt;Fedy&lt;/a&gt;.
 &lt;/p&gt;
&lt;p&gt;Program umożliwia na:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;łatwą instalację wielu aplikacji jak i kodeków&lt;/li&gt;
&lt;li&gt;instalację czcionek Microsoftu&lt;/li&gt;
&lt;li&gt;konfiugrację wygładzania czcionek czy też konfigurację touchpadu&lt;/li&gt;
&lt;li&gt;dograć dodatkowe tematy Gnome oraz paczki ikon (polecam Paper oraz Arc)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Narzędzie można zainstalować za pomocą polecenia:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl https://www.folkswithhats.org/installer &lt;span class="p"&gt;|&lt;/span&gt; sudo bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a uruchomić odszukując Fedy w Dashu.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fedy" src="https://czerus.github.io/img/fedy.png" style="width: 802px; height: auto; max-width: 100%;"/&gt;&lt;/p&gt;</content><category term="fedora"></category><category term="linux"></category><category term="fedy"></category></entry><entry><title>PIT za 2016 na Fedorze</title><link href="https://czerus.github.io/pit-za-2016-na-fedorze.html" rel="alternate"></link><published>2017-03-08T10:20:00+01:00</published><updated>2017-03-08T10:20:00+01:00</updated><author><name>czerus</name></author><id>tag:czerus.github.io,2017-03-08:/pit-za-2016-na-fedorze.html</id><summary type="html">
&lt;p&gt;W pracy od kilku już lat pracuję w środowisku Linux. Mimo wszystkich wad Linuxa
przyzwyczaiłem się i polubiłem go. Na magazynie używam Ubuntu 16.04. Ostatnio
"z braku wolnego czasu" postanowiłem spróbować przejść na drugą stronę także w
domu. Głównym komputerem żony jest telefon więc nie rzucała kłód pod nogi.
Wybór padł na Fedorę 25. Dlaczego nie na Ubuntu to już opiszę w innym poście.
</summary><content type="html">
&lt;p&gt;W pracy od kilku już lat pracuję w środowisku Linux. Mimo wszystkich wad Linuxa
przyzwyczaiłem się i polubiłem go. Na magazynie używam Ubuntu 16.04. Ostatnio
"z braku wolnego czasu" postanowiłem spróbować przejść na drugą stronę także w
domu. Głównym komputerem żony jest telefon więc nie rzucała kłód pod nogi.
Wybór padł na Fedorę 25. Dlaczego nie na Ubuntu to już opiszę w innym poście.
 &lt;/p&gt;
&lt;h2&gt;Pierwszy problem&lt;/h2&gt;
&lt;p&gt;Tak czy siak, tuż po instalacji przyszedł czas na pierwszy poważny sprawdzian -
wypełnienie PITa. Szybkie googlanie dało odpowiedź w postaci aplikacji
&lt;a href="https://www.e-pity.pl/pobierz_darmowy_program/"&gt;e-pity.py&lt;/a&gt;. Problem w tym, że
wymaga ona Adobe AIR i jeszcze kilku innych bibliotek. Postanowiłem rozejrzeć się
za inną opcją a konkretnie za programem używaym dotychczas na Windowsie od
firmy IPS. I rzeczywiście jest wersja &lt;a href="http://www.ips-infor.com.pl/index.php?ml=1&amp;amp;mg=3"&gt;PITY2016NG&lt;/a&gt;
ale tylko na "okienka". Postanowiłem spróbować odpalić ją za pomocą &lt;code&gt;wine&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Instalacja&lt;/h2&gt;
&lt;p&gt;Polecenie&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo dnf install wine
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Zainstaluje wine oraz kilka niezbędnych dodatków. Następnie pobieramy instalator pogramu
klikamy prawym przyciskiem mszki na nim i z menu "Otwórz za pomocą innego programu"
wybieramy "Wine Windows Program Launcher".&lt;/p&gt;
&lt;p&gt;&lt;img alt="Wybór opcji menu" src="https://czerus.github.io/img/wine_instalator.png" style="width: 928px; height: auto; max-width: 100%;"/&gt;&lt;/p&gt;
&lt;p&gt;Uruchomi się standardowy instalator windows gdzie klikamy po prostu dalej, dalej itd.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Kreator instalacji PITy 2016 IPS" src="https://czerus.github.io/img/kreator_instalacji_pity_ips.png" style="width: 665px; height: auto; max-width: 100%;"/&gt;&lt;/p&gt;
&lt;p&gt;Po zakończonej instalacji program możemy znaleźć w Dashu jako &lt;strong&gt;PITy 2016&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Wyniki&lt;/h2&gt;
&lt;p&gt;Po odpaleniu programu bez problemu mogłem wypełnić PIT-37, wysłać na Testowy serwer
Ministerstwa a także wysłać już finalną wersję pitu do rozliczenia.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Okno programu PITy 2016" src="https://czerus.github.io/img/pity2016_ips.png" style="width: 896px; height: auto; max-width: 100%;"/&gt;&lt;/p&gt;
&lt;h2&gt;Problemy&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Drukowanie do PDF tworzy PDF z pustymi stronami. Aby rozwiązać ten problem
należy zainstalować cups-pdf (&lt;code&gt;sudo dnf install cups-pdf&lt;/code&gt;) i aby utworzyć PDF wybrać "Plik" -&amp;gt; "Drukuj" -&amp;gt;
a w profilu (w oknie ustawień drukowania) "Cups-PDF".&lt;/li&gt;
&lt;li&gt;Wine przechwytuje &lt;code&gt;ALT+Tab&lt;/code&gt;, który przestaje działać w systemie.&lt;/li&gt;
&lt;li&gt;Po wyłączeniu aplikacji jej ikonka dalej pozostaje w doku (mimo, że nie ma nawet
  procesu aplikacji).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Na szczęście główna funkcjonalność działa a z problemami można się jakoś przemęczyć ten jeden raz w roku.&lt;/p&gt;
&lt;h2&gt;Ubuntu&lt;/h2&gt;
&lt;p&gt;Okazuje się, że na Ubuntu 16.04 (kernel 4.8) zarówno drukowanie/eksport do PDF jak i wyłączenie
aplikacji oraz &lt;code&gt;ALT+Tab&lt;/code&gt; działa bez problemów. Więc obstawiam, że głównym winowajcą na Fedorze jest
Wayland.&lt;/p&gt;</content><category term="fedora"></category><category term="linux"></category><category term="pit"></category><category term="wine"></category></entry></feed>